/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * API админской части
 * Авторизация для запросов происходит через `Authorization` ввиде передачи логина и пароля в __base64__. Формат передачи __Basic login:password__
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = '/';

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * Идентификатор аккаунта
     * @type {number}
     * @memberof Account
     */
    accountId: number;
    /**
     * Логин
     * @type {string}
     * @memberof Account
     */
    login: string;
    /**
     * ФИО
     * @type {string}
     * @memberof Account
     */
    fio: string;
    /**
     * Идентификатор роли
     * @type {number}
     * @memberof Account
     */
    roleId: number;
    /**
     * Текущее количество баллов
     * @type {number}
     * @memberof Account
     */
    score: number;
}

/**
 * 
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * Идентификатор курса
     * @type {number}
     * @memberof Category
     */
    categoryId: number;
    /**
     * Название курса
     * @type {string}
     * @memberof Category
     */
    name: string;
    /**
     * Описание курса
     * @type {string}
     * @memberof Category
     */
    description: string;
    /**
     * Идентификатор картинки
     * @type {number}
     * @memberof Category
     */
    pictureId: number;
}

/**
 * 
 * @export
 * @interface CategoryVideo
 */
export interface CategoryVideo {
    /**
     * Идентификатор видео в курсе
     * @type {number}
     * @memberof CategoryVideo
     */
    categoryVideoId: number;
    /**
     * Идентификатор курса
     * @type {number}
     * @memberof CategoryVideo
     */
    categoryId: number;
    /**
     * Название видео
     * @type {string}
     * @memberof CategoryVideo
     */
    name: string;
    /**
     * Описание видео
     * @type {string}
     * @memberof CategoryVideo
     */
    description: string;
    /**
     * Идентификатор картинки
     * @type {number}
     * @memberof CategoryVideo
     */
    pictureId: number;
    /**
     * Идентификатор видео
     * @type {number}
     * @memberof CategoryVideo
     */
    videoId: number;
}

/**
 * 
 * @export
 * @interface HistoryScore
 */
export interface HistoryScore {
    /**
     * Идентификатор истории
     * @type {number}
     * @memberof HistoryScore
     */
    historyScoreId: number;
    /**
     * Дата изменения баллов. Формат dd.MM.yyyy HH:mm:ss
     * @type {string}
     * @memberof HistoryScore
     */
    created: string;
    /**
     * На сколько баллов было изменение
     * @type {number}
     * @memberof HistoryScore
     */
    score: number;
}

/**
 * 
 * @export
 * @interface ReqPostAccount
 */
export interface ReqPostAccount {
    /**
     * Логин
     * @type {string}
     * @memberof ReqPostAccount
     */
    login: string;
    /**
     * Пароль
     * @type {string}
     * @memberof ReqPostAccount
     */
    password: string;
    /**
     * ФИО
     * @type {string}
     * @memberof ReqPostAccount
     */
    fio: string;
    /**
     * Идентификатор роли
     * @type {number}
     * @memberof ReqPostAccount
     */
    roleId: number;
    /**
     * Начальное количество баллов
     * @type {number}
     * @memberof ReqPostAccount
     */
    score: number;
}

/**
 * 
 * @export
 * @interface ReqPostCategory
 */
export interface ReqPostCategory {
    /**
     * Название курса
     * @type {string}
     * @memberof ReqPostCategory
     */
    name: string;
    /**
     * Описание курса
     * @type {string}
     * @memberof ReqPostCategory
     */
    description: string;
}

/**
 * 
 * @export
 * @interface ReqPostCategoryVideo
 */
export interface ReqPostCategoryVideo {
    /**
     * Идентификатор курса
     * @type {number}
     * @memberof ReqPostCategoryVideo
     */
    categoryId: number;
    /**
     * Название видео
     * @type {string}
     * @memberof ReqPostCategoryVideo
     */
    name: string;
    /**
     * Описание видео
     * @type {string}
     * @memberof ReqPostCategoryVideo
     */
    description: string;
}

/**
 * 
 * @export
 * @interface ReqPostPush
 */
export interface ReqPostPush {
    /**
     * Заголовок push-уведомления
     * @type {string}
     * @memberof ReqPostPush
     */
    title: string;
    /**
     * Сообщение push-уведомления
     * @type {string}
     * @memberof ReqPostPush
     */
    body: string;
}

/**
 * 
 * @export
 * @interface ReqPutAccount
 */
export interface ReqPutAccount {
    /**
     * Идентификатор аккаунта
     * @type {number}
     * @memberof ReqPutAccount
     */
    accountId: number;
    /**
     * Логин
     * @type {string}
     * @memberof ReqPutAccount
     */
    login?: string;
    /**
     * Пароль
     * @type {string}
     * @memberof ReqPutAccount
     */
    password?: string;
    /**
     * ФИО
     * @type {string}
     * @memberof ReqPutAccount
     */
    fio?: string;
    /**
     * Идентификатор роли
     * @type {number}
     * @memberof ReqPutAccount
     */
    roleId?: number;
    /**
     * Количество баллов
     * @type {number}
     * @memberof ReqPutAccount
     */
    score?: number;
}

/**
 * 
 * @export
 * @interface ReqPutCategory
 */
export interface ReqPutCategory {
    /**
     * Идентификатор курса
     * @type {number}
     * @memberof ReqPutCategory
     */
    categoryId: number;
    /**
     * Название курса
     * @type {string}
     * @memberof ReqPutCategory
     */
    name?: string;
    /**
     * Описание курса
     * @type {string}
     * @memberof ReqPutCategory
     */
    description?: string;
}

/**
 * 
 * @export
 * @interface ReqPutCategoryVideo
 */
export interface ReqPutCategoryVideo {
    /**
     * Идентификатор видео в курсе
     * @type {number}
     * @memberof ReqPutCategoryVideo
     */
    categoryVideoId: number;
    /**
     * Идентификатор курса
     * @type {number}
     * @memberof ReqPutCategoryVideo
     */
    categoryId?: number;
    /**
     * Название видео
     * @type {string}
     * @memberof ReqPutCategoryVideo
     */
    name?: string;
    /**
     * Описание видео
     * @type {string}
     * @memberof ReqPutCategoryVideo
     */
    description?: string;
}

/**
 * 
 * @export
 * @interface ResEmpty
 */
export interface ResEmpty {
    /**
     * Код ошибки
     * @type {number}
     * @memberof ResEmpty
     */
    code: number;
    /**
     * Текст ошибки
     * @type {string}
     * @memberof ResEmpty
     */
    message: string;
    /**
     * Успешность запроса
     * @type {boolean}
     * @memberof ResEmpty
     */
    success: boolean;
    /**
     * 
     * @type {any}
     * @memberof ResEmpty
     */
    data?: any;
}

/**
 * 
 * @export
 * @interface ResGetAccount
 */
export interface ResGetAccount {
    /**
     * Код ошибки
     * @type {number}
     * @memberof ResGetAccount
     */
    code: number;
    /**
     * Текст ошибки
     * @type {string}
     * @memberof ResGetAccount
     */
    message: string;
    /**
     * Успешность запроса
     * @type {boolean}
     * @memberof ResGetAccount
     */
    success: boolean;
    /**
     * 
     * @type {Account}
     * @memberof ResGetAccount
     */
    data?: Account;
}

/**
 * 
 * @export
 * @interface ResGetAccounts
 */
export interface ResGetAccounts {
    /**
     * Код ошибки
     * @type {number}
     * @memberof ResGetAccounts
     */
    code: number;
    /**
     * Текст ошибки
     * @type {string}
     * @memberof ResGetAccounts
     */
    message: string;
    /**
     * Успешность запроса
     * @type {boolean}
     * @memberof ResGetAccounts
     */
    success: boolean;
    /**
     * 
     * @type {ResGetAccountsData}
     * @memberof ResGetAccounts
     */
    data?: ResGetAccountsData;
}

/**
 * 
 * @export
 * @interface ResGetAccountsData
 */
export interface ResGetAccountsData {
    /**
     * Список аккаунтов
     * @type {Array<Account>}
     * @memberof ResGetAccountsData
     */
    accounts: Array<Account>;
}

/**
 * 
 * @export
 * @interface ResGetCategories
 */
export interface ResGetCategories {
    /**
     * Код ошибки
     * @type {number}
     * @memberof ResGetCategories
     */
    code: number;
    /**
     * Текст ошибки
     * @type {string}
     * @memberof ResGetCategories
     */
    message: string;
    /**
     * Успешность запроса
     * @type {boolean}
     * @memberof ResGetCategories
     */
    success: boolean;
    /**
     * 
     * @type {ResGetCategoriesData}
     * @memberof ResGetCategories
     */
    data?: ResGetCategoriesData;
}

/**
 * 
 * @export
 * @interface ResGetCategoriesData
 */
export interface ResGetCategoriesData {
    /**
     * Список курсов
     * @type {Array<Category>}
     * @memberof ResGetCategoriesData
     */
    categories: Array<Category>;
}

/**
 * 
 * @export
 * @interface ResGetCategory
 */
export interface ResGetCategory {
    /**
     * Код ошибки
     * @type {number}
     * @memberof ResGetCategory
     */
    code: number;
    /**
     * Текст ошибки
     * @type {string}
     * @memberof ResGetCategory
     */
    message: string;
    /**
     * Успешность запроса
     * @type {boolean}
     * @memberof ResGetCategory
     */
    success: boolean;
    /**
     * 
     * @type {Category}
     * @memberof ResGetCategory
     */
    data?: Category;
}

/**
 * 
 * @export
 * @interface ResGetCategoryVideo
 */
export interface ResGetCategoryVideo {
    /**
     * Код ошибки
     * @type {number}
     * @memberof ResGetCategoryVideo
     */
    code: number;
    /**
     * Текст ошибки
     * @type {string}
     * @memberof ResGetCategoryVideo
     */
    message: string;
    /**
     * Успешность запроса
     * @type {boolean}
     * @memberof ResGetCategoryVideo
     */
    success: boolean;
    /**
     * 
     * @type {CategoryVideo}
     * @memberof ResGetCategoryVideo
     */
    data?: CategoryVideo;
}

/**
 * 
 * @export
 * @interface ResGetCategoryVideos
 */
export interface ResGetCategoryVideos {
    /**
     * Код ошибки
     * @type {number}
     * @memberof ResGetCategoryVideos
     */
    code: number;
    /**
     * Текст ошибки
     * @type {string}
     * @memberof ResGetCategoryVideos
     */
    message: string;
    /**
     * Успешность запроса
     * @type {boolean}
     * @memberof ResGetCategoryVideos
     */
    success: boolean;
    /**
     * 
     * @type {ResGetCategoryVideosData}
     * @memberof ResGetCategoryVideos
     */
    data?: ResGetCategoryVideosData;
}

/**
 * 
 * @export
 * @interface ResGetCategoryVideosData
 */
export interface ResGetCategoryVideosData {
    /**
     * Список видео курса
     * @type {Array<CategoryVideo>}
     * @memberof ResGetCategoryVideosData
     */
    categoryVideos: Array<CategoryVideo>;
}

/**
 * 
 * @export
 * @interface ResGetHistoryScore
 */
export interface ResGetHistoryScore {
    /**
     * Код ошибки
     * @type {number}
     * @memberof ResGetHistoryScore
     */
    code: number;
    /**
     * Текст ошибки
     * @type {string}
     * @memberof ResGetHistoryScore
     */
    message: string;
    /**
     * Успешность запроса
     * @type {boolean}
     * @memberof ResGetHistoryScore
     */
    success: boolean;
    /**
     * 
     * @type {ResGetHistoryScoreData}
     * @memberof ResGetHistoryScore
     */
    data?: ResGetHistoryScoreData;
}

/**
 * 
 * @export
 * @interface ResGetHistoryScoreData
 */
export interface ResGetHistoryScoreData {
    /**
     * История баллов
     * @type {Array<HistoryScore>}
     * @memberof ResGetHistoryScoreData
     */
    historyScores: Array<HistoryScore>;
}

/**
 * 
 * @export
 * @interface ResGetPicturesMain
 */
export interface ResGetPicturesMain {
    /**
     * Код ошибки
     * @type {number}
     * @memberof ResGetPicturesMain
     */
    code: number;
    /**
     * Текст ошибки
     * @type {string}
     * @memberof ResGetPicturesMain
     */
    message: string;
    /**
     * Успешность запроса
     * @type {boolean}
     * @memberof ResGetPicturesMain
     */
    success: boolean;
    /**
     * 
     * @type {ResGetPicturesMainData}
     * @memberof ResGetPicturesMain
     */
    data?: ResGetPicturesMainData;
}

/**
 * 
 * @export
 * @interface ResGetPicturesMainData
 */
export interface ResGetPicturesMainData {
    /**
     * Список идентификаторов картинок
     * @type {Array<number>}
     * @memberof ResGetPicturesMainData
     */
    pictureIds: Array<number>;
}


/**
 * AccountApi - fetch parameter creator
 * @export
 */
export const AccountApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Удаление аккаунта
         * @param {number} accountId Идентификатор аккаунта
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountDelete(accountId: number, options: any = {}): FetchArgs {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling accountDelete.');
            }
            const localVarPath = `/account`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Получение информации об аккаунте
         * @param {number} accountId Идентификатор аккаунта
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountGet(accountId: number, options: any = {}): FetchArgs {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling accountGet.');
            }
            const localVarPath = `/account`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Создание аккаунта
         * @param {ReqPostAccount} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountPost(body: ReqPostAccount, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling accountPost.');
            }
            const localVarPath = `/account`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ReqPostAccount" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Изменение данных аккаунта
         * @param {ReqPutAccount} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountPut(body: ReqPutAccount, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling accountPut.');
            }
            const localVarPath = `/account`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ReqPutAccount" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Получение информации об аккаунтах
         * @param {number} [offset] Смещение получения записей
         * @param {number} [limit] Лимит получения записей
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsGet(offset?: number, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/accounts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Получение информации о баллах аккаунта
         * @param {number} accountId Идентификатор аккаунта
         * @param {number} [offset] Смещение получения записей
         * @param {number} [limit] Лимит получения записей
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historyscoreGet(accountId: number, offset?: number, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'accountId' is not null or undefined
            if (accountId === null || accountId === undefined) {
                throw new RequiredError('accountId','Required parameter accountId was null or undefined when calling historyscoreGet.');
            }
            const localVarPath = `/historyscore`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (accountId !== undefined) {
                localVarQueryParameter['account_id'] = accountId;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Удаление картинки слайда на главном экране
         * @param {number} fileId Идентификатор картинки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        picturesmainDelete(fileId: number, options: any = {}): FetchArgs {
            // verify required parameter 'fileId' is not null or undefined
            if (fileId === null || fileId === undefined) {
                throw new RequiredError('fileId','Required parameter fileId was null or undefined when calling picturesmainDelete.');
            }
            const localVarPath = `/picturesmain`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fileId !== undefined) {
                localVarQueryParameter['file_id'] = fileId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Список идентификаторов картинок для слайда на главном экране
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        picturesmainGet(options: any = {}): FetchArgs {
            const localVarPath = `/picturesmain`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Добавление картинок для слайда на главном экране
         * @param {any} picture Картинка
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        picturesmainPost(picture: any, options: any = {}): FetchArgs {
            // verify required parameter 'picture' is not null or undefined
            if (picture === null || picture === undefined) {
                throw new RequiredError('picture','Required parameter picture was null or undefined when calling picturesmainPost.');
            }
            const localVarPath = `/picturesmain`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (picture !== undefined) {
                localVarFormParams.set('picture', picture as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Удаление аккаунта
         * @param {number} accountId Идентификатор аккаунта
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountDelete(accountId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResEmpty> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).accountDelete(accountId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return optimisation(response.json());
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Получение информации об аккаунте
         * @param {number} accountId Идентификатор аккаунта
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountGet(accountId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResGetAccount> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).accountGet(accountId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return optimisation(response.json());
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Создание аккаунта
         * @param {ReqPostAccount} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountPost(body: ReqPostAccount, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResGetAccount> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).accountPost(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return optimisation(response.json());
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Изменение данных аккаунта
         * @param {ReqPutAccount} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountPut(body: ReqPutAccount, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResGetAccount> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).accountPut(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return optimisation(response.json());
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Получение информации об аккаунтах
         * @param {number} [offset] Смещение получения записей
         * @param {number} [limit] Лимит получения записей
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsGet(offset?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResGetAccounts> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).accountsGet(offset, limit, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return optimisation(response.json());
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Получение информации о баллах аккаунта
         * @param {number} accountId Идентификатор аккаунта
         * @param {number} [offset] Смещение получения записей
         * @param {number} [limit] Лимит получения записей
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historyscoreGet(accountId: number, offset?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResGetHistoryScore> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).historyscoreGet(accountId, offset, limit, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return optimisation(response.json());
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Удаление картинки слайда на главном экране
         * @param {number} fileId Идентификатор картинки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        picturesmainDelete(fileId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResEmpty> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).picturesmainDelete(fileId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return optimisation(response.json());
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Список идентификаторов картинок для слайда на главном экране
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        picturesmainGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResGetPicturesMain> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).picturesmainGet(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return optimisation(response.json());
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Добавление картинок для слайда на главном экране
         * @param {any} picture Картинка
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        picturesmainPost(picture: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResGetPicturesMain> {
            const localVarFetchArgs = AccountApiFetchParamCreator(configuration).picturesmainPost(picture, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return optimisation(response.json());
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Удаление аккаунта
         * @param {number} accountId Идентификатор аккаунта
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountDelete(accountId: number, options?: any) {
            return AccountApiFp(configuration).accountDelete(accountId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Получение информации об аккаунте
         * @param {number} accountId Идентификатор аккаунта
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountGet(accountId: number, options?: any) {
            return AccountApiFp(configuration).accountGet(accountId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Создание аккаунта
         * @param {ReqPostAccount} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountPost(body: ReqPostAccount, options?: any) {
            return AccountApiFp(configuration).accountPost(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Изменение данных аккаунта
         * @param {ReqPutAccount} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountPut(body: ReqPutAccount, options?: any) {
            return AccountApiFp(configuration).accountPut(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Получение информации об аккаунтах
         * @param {number} [offset] Смещение получения записей
         * @param {number} [limit] Лимит получения записей
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsGet(offset?: number, limit?: number, options?: any) {
            return AccountApiFp(configuration).accountsGet(offset, limit, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Получение информации о баллах аккаунта
         * @param {number} accountId Идентификатор аккаунта
         * @param {number} [offset] Смещение получения записей
         * @param {number} [limit] Лимит получения записей
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        historyscoreGet(accountId: number, offset?: number, limit?: number, options?: any) {
            return AccountApiFp(configuration).historyscoreGet(accountId, offset, limit, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Удаление картинки слайда на главном экране
         * @param {number} fileId Идентификатор картинки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        picturesmainDelete(fileId: number, options?: any) {
            return AccountApiFp(configuration).picturesmainDelete(fileId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Список идентификаторов картинок для слайда на главном экране
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        picturesmainGet(options?: any) {
            return AccountApiFp(configuration).picturesmainGet(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Добавление картинок для слайда на главном экране
         * @param {any} picture Картинка
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        picturesmainPost(picture: any, options?: any) {
            return AccountApiFp(configuration).picturesmainPost(picture, options)(fetch, basePath);
        },
    };
};

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI {
    /**
     * 
     * @summary Удаление аккаунта
     * @param {number} accountId Идентификатор аккаунта
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountDelete(accountId: number, options?: any) {
        return AccountApiFp(this.configuration).accountDelete(accountId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Получение информации об аккаунте
     * @param {number} accountId Идентификатор аккаунта
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountGet(accountId: number, options?: any) {
        return AccountApiFp(this.configuration).accountGet(accountId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Создание аккаунта
     * @param {ReqPostAccount} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountPost(body: ReqPostAccount, options?: any) {
        return AccountApiFp(this.configuration).accountPost(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Изменение данных аккаунта
     * @param {ReqPutAccount} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountPut(body: ReqPutAccount, options?: any) {
        return AccountApiFp(this.configuration).accountPut(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Получение информации об аккаунтах
     * @param {number} [offset] Смещение получения записей
     * @param {number} [limit] Лимит получения записей
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountsGet(offset?: number, limit?: number, options?: any) {
        return AccountApiFp(this.configuration).accountsGet(offset, limit, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Получение информации о баллах аккаунта
     * @param {number} accountId Идентификатор аккаунта
     * @param {number} [offset] Смещение получения записей
     * @param {number} [limit] Лимит получения записей
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public historyscoreGet(accountId: number, offset?: number, limit?: number, options?: any) {
        return AccountApiFp(this.configuration).historyscoreGet(accountId, offset, limit, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Удаление картинки слайда на главном экране
     * @param {number} fileId Идентификатор картинки
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public picturesmainDelete(fileId: number, options?: any) {
        return AccountApiFp(this.configuration).picturesmainDelete(fileId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Список идентификаторов картинок для слайда на главном экране
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public picturesmainGet(options?: any) {
        return AccountApiFp(this.configuration).picturesmainGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Добавление картинок для слайда на главном экране
     * @param {any} picture Картинка
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public picturesmainPost(picture: any, options?: any) {
        return AccountApiFp(this.configuration).picturesmainPost(picture, options)(this.fetch, this.basePath);
    }

}

/**
 * CategoryApi - fetch parameter creator
 * @export
 */
export const CategoryApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Получение информации о курсах
         * @param {number} [offset] Смещение получения записей
         * @param {number} [limit] Лимит получения записей
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesGet(offset?: number, limit?: number, options: any = {}): FetchArgs {
            const localVarPath = `/categories`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Удаление курса
         * @param {number} categoryId Идентификатор курса
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryDelete(categoryId: number, options: any = {}): FetchArgs {
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new RequiredError('categoryId','Required parameter categoryId was null or undefined when calling categoryDelete.');
            }
            const localVarPath = `/category`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['category_id'] = categoryId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Получение информации о курсе
         * @param {number} categoryId Идентификатор курса
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryGet(categoryId: number, options: any = {}): FetchArgs {
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new RequiredError('categoryId','Required parameter categoryId was null or undefined when calling categoryGet.');
            }
            const localVarPath = `/category`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['category_id'] = categoryId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Создание курса
         * @param {string} json JSON объект ReqPostCategory
         * @param {any} picture Картинка
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryPost(json: string, picture: any, options: any = {}): FetchArgs {
            // verify required parameter 'json' is not null or undefined
            if (json === null || json === undefined) {
                throw new RequiredError('json','Required parameter json was null or undefined when calling categoryPost.');
            }
            // verify required parameter 'picture' is not null or undefined
            if (picture === null || picture === undefined) {
                throw new RequiredError('picture','Required parameter picture was null or undefined when calling categoryPost.');
            }
            const localVarPath = `/category`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (json !== undefined) {
                localVarFormParams.set('json', json as any);
            }

            if (picture !== undefined) {
                localVarFormParams.set('picture', picture as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Изменение данных курса
         * @param {string} json JSON объект ReqPutCategory
         * @param {any} [picture] Картинка
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryPut(json: string, picture?: any, options: any = {}): FetchArgs {
            // verify required parameter 'json' is not null or undefined
            if (json === null || json === undefined) {
                throw new RequiredError('json','Required parameter json was null or undefined when calling categoryPut.');
            }
            const localVarPath = `/category`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (json !== undefined) {
                localVarFormParams.set('json', json as any);
            }

            if (picture !== undefined) {
                localVarFormParams.set('picture', picture as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Удаление видео из курса
         * @param {number} categoryVideoId Идентификатор видео в курсе
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryvideoDelete(categoryVideoId: number, options: any = {}): FetchArgs {
            // verify required parameter 'categoryVideoId' is not null or undefined
            if (categoryVideoId === null || categoryVideoId === undefined) {
                throw new RequiredError('categoryVideoId','Required parameter categoryVideoId was null or undefined when calling categoryvideoDelete.');
            }
            const localVarPath = `/categoryvideo`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (categoryVideoId !== undefined) {
                localVarQueryParameter['category_video_id'] = categoryVideoId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Получение информации о видео в курсе
         * @param {number} categoryVideoId Идентификатор видео в курсе
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryvideoGet(categoryVideoId: number, options: any = {}): FetchArgs {
            // verify required parameter 'categoryVideoId' is not null or undefined
            if (categoryVideoId === null || categoryVideoId === undefined) {
                throw new RequiredError('categoryVideoId','Required parameter categoryVideoId was null or undefined when calling categoryvideoGet.');
            }
            const localVarPath = `/categoryvideo`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (categoryVideoId !== undefined) {
                localVarQueryParameter['category_video_id'] = categoryVideoId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Создание видео в курсе
         * @param {string} json JSON объект ReqPostCategoryVideo
         * @param {any} picture Картинка
         * @param {any} video Видео
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryvideoPost(json: string, picture: any, video: any, options: any = {}): FetchArgs {
            // verify required parameter 'json' is not null or undefined
            if (json === null || json === undefined) {
                throw new RequiredError('json','Required parameter json was null or undefined when calling categoryvideoPost.');
            }
            // verify required parameter 'picture' is not null or undefined
            if (picture === null || picture === undefined) {
                throw new RequiredError('picture','Required parameter picture was null or undefined when calling categoryvideoPost.');
            }
            // verify required parameter 'video' is not null or undefined
            if (video === null || video === undefined) {
                throw new RequiredError('video','Required parameter video was null or undefined when calling categoryvideoPost.');
            }
            const localVarPath = `/categoryvideo`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (json !== undefined) {
                localVarFormParams.set('json', json as any);
            }

            if (picture !== undefined) {
                localVarFormParams.set('picture', picture as any);
            }

            if (video !== undefined) {
                localVarFormParams.set('video', video as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Изменение данных видео в курсе
         * @param {string} json JSON объект ReqPutCategoryVideo
         * @param {any} [picture] Картинка
         * @param {any} [video] Видео
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryvideoPut(json: string, picture?: any, video?: any, options: any = {}): FetchArgs {
            // verify required parameter 'json' is not null or undefined
            if (json === null || json === undefined) {
                throw new RequiredError('json','Required parameter json was null or undefined when calling categoryvideoPut.');
            }
            const localVarPath = `/categoryvideo`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (json !== undefined) {
                localVarFormParams.set('json', json as any);
            }

            if (picture !== undefined) {
                localVarFormParams.set('picture', picture as any);
            }

            if (video !== undefined) {
                localVarFormParams.set('video', video as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Получение информации о видео курса
         * @param {number} categoryId Идентификатор курса
         * @param {number} [offset] Смещение получения записей
         * @param {number} [limit] Лимит получения записей
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryvideosGet(categoryId: number, offset?: number, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new RequiredError('categoryId','Required parameter categoryId was null or undefined when calling categoryvideosGet.');
            }
            const localVarPath = `/categoryvideos`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['category_id'] = categoryId;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoryApi - functional programming interface
 * @export
 */
export const CategoryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Получение информации о курсах
         * @param {number} [offset] Смещение получения записей
         * @param {number} [limit] Лимит получения записей
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesGet(offset?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResGetCategories> {
            const localVarFetchArgs = CategoryApiFetchParamCreator(configuration).categoriesGet(offset, limit, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return optimisation(response.json());
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Удаление курса
         * @param {number} categoryId Идентификатор курса
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryDelete(categoryId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResEmpty> {
            const localVarFetchArgs = CategoryApiFetchParamCreator(configuration).categoryDelete(categoryId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return optimisation(response.json());
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Получение информации о курсе
         * @param {number} categoryId Идентификатор курса
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryGet(categoryId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResGetCategory> {
            const localVarFetchArgs = CategoryApiFetchParamCreator(configuration).categoryGet(categoryId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return optimisation(response.json());
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Создание курса
         * @param {string} json JSON объект ReqPostCategory
         * @param {any} picture Картинка
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryPost(json: string, picture: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResGetCategory> {
            const localVarFetchArgs = CategoryApiFetchParamCreator(configuration).categoryPost(json, picture, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return optimisation(response.json());
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Изменение данных курса
         * @param {string} json JSON объект ReqPutCategory
         * @param {any} [picture] Картинка
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryPut(json: string, picture?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResGetCategory> {
            const localVarFetchArgs = CategoryApiFetchParamCreator(configuration).categoryPut(json, picture, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return optimisation(response.json());
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Удаление видео из курса
         * @param {number} categoryVideoId Идентификатор видео в курсе
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryvideoDelete(categoryVideoId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResEmpty> {
            const localVarFetchArgs = CategoryApiFetchParamCreator(configuration).categoryvideoDelete(categoryVideoId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return optimisation(response.json());
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Получение информации о видео в курсе
         * @param {number} categoryVideoId Идентификатор видео в курсе
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryvideoGet(categoryVideoId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResGetCategoryVideo> {
            const localVarFetchArgs = CategoryApiFetchParamCreator(configuration).categoryvideoGet(categoryVideoId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return optimisation(response.json());
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Создание видео в курсе
         * @param {string} json JSON объект ReqPostCategoryVideo
         * @param {any} picture Картинка
         * @param {any} video Видео
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryvideoPost(json: string, picture: any, video: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResGetCategoryVideo> {
            const localVarFetchArgs = CategoryApiFetchParamCreator(configuration).categoryvideoPost(json, picture, video, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return optimisation(response.json());
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Изменение данных видео в курсе
         * @param {string} json JSON объект ReqPutCategoryVideo
         * @param {any} [picture] Картинка
         * @param {any} [video] Видео
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryvideoPut(json: string, picture?: any, video?: any, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResGetCategoryVideo> {
            const localVarFetchArgs = CategoryApiFetchParamCreator(configuration).categoryvideoPut(json, picture, video, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return optimisation(response.json());
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Получение информации о видео курса
         * @param {number} categoryId Идентификатор курса
         * @param {number} [offset] Смещение получения записей
         * @param {number} [limit] Лимит получения записей
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryvideosGet(categoryId: number, offset?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResGetCategoryVideos> {
            const localVarFetchArgs = CategoryApiFetchParamCreator(configuration).categoryvideosGet(categoryId, offset, limit, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return optimisation(response.json());
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CategoryApi - factory interface
 * @export
 */
export const CategoryApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Получение информации о курсах
         * @param {number} [offset] Смещение получения записей
         * @param {number} [limit] Лимит получения записей
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoriesGet(offset?: number, limit?: number, options?: any) {
            return CategoryApiFp(configuration).categoriesGet(offset, limit, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Удаление курса
         * @param {number} categoryId Идентификатор курса
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryDelete(categoryId: number, options?: any) {
            return CategoryApiFp(configuration).categoryDelete(categoryId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Получение информации о курсе
         * @param {number} categoryId Идентификатор курса
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryGet(categoryId: number, options?: any) {
            return CategoryApiFp(configuration).categoryGet(categoryId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Создание курса
         * @param {string} json JSON объект ReqPostCategory
         * @param {any} picture Картинка
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryPost(json: string, picture: any, options?: any) {
            return CategoryApiFp(configuration).categoryPost(json, picture, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Изменение данных курса
         * @param {string} json JSON объект ReqPutCategory
         * @param {any} [picture] Картинка
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryPut(json: string, picture?: any, options?: any) {
            return CategoryApiFp(configuration).categoryPut(json, picture, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Удаление видео из курса
         * @param {number} categoryVideoId Идентификатор видео в курсе
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryvideoDelete(categoryVideoId: number, options?: any) {
            return CategoryApiFp(configuration).categoryvideoDelete(categoryVideoId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Получение информации о видео в курсе
         * @param {number} categoryVideoId Идентификатор видео в курсе
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryvideoGet(categoryVideoId: number, options?: any) {
            return CategoryApiFp(configuration).categoryvideoGet(categoryVideoId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Создание видео в курсе
         * @param {string} json JSON объект ReqPostCategoryVideo
         * @param {any} picture Картинка
         * @param {any} video Видео
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryvideoPost(json: string, picture: any, video: any, options?: any) {
            return CategoryApiFp(configuration).categoryvideoPost(json, picture, video, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Изменение данных видео в курсе
         * @param {string} json JSON объект ReqPutCategoryVideo
         * @param {any} [picture] Картинка
         * @param {any} [video] Видео
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryvideoPut(json: string, picture?: any, video?: any, options?: any) {
            return CategoryApiFp(configuration).categoryvideoPut(json, picture, video, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Получение информации о видео курса
         * @param {number} categoryId Идентификатор курса
         * @param {number} [offset] Смещение получения записей
         * @param {number} [limit] Лимит получения записей
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        categoryvideosGet(categoryId: number, offset?: number, limit?: number, options?: any) {
            return CategoryApiFp(configuration).categoryvideosGet(categoryId, offset, limit, options)(fetch, basePath);
        },
    };
};

/**
 * CategoryApi - object-oriented interface
 * @export
 * @class CategoryApi
 * @extends {BaseAPI}
 */
export class CategoryApi extends BaseAPI {
    /**
     * 
     * @summary Получение информации о курсах
     * @param {number} [offset] Смещение получения записей
     * @param {number} [limit] Лимит получения записей
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public categoriesGet(offset?: number, limit?: number, options?: any) {
        return CategoryApiFp(this.configuration).categoriesGet(offset, limit, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Удаление курса
     * @param {number} categoryId Идентификатор курса
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public categoryDelete(categoryId: number, options?: any) {
        return CategoryApiFp(this.configuration).categoryDelete(categoryId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Получение информации о курсе
     * @param {number} categoryId Идентификатор курса
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public categoryGet(categoryId: number, options?: any) {
        return CategoryApiFp(this.configuration).categoryGet(categoryId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Создание курса
     * @param {string} json JSON объект ReqPostCategory
     * @param {any} picture Картинка
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public categoryPost(json: string, picture: any, options?: any) {
        return CategoryApiFp(this.configuration).categoryPost(json, picture, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Изменение данных курса
     * @param {string} json JSON объект ReqPutCategory
     * @param {any} [picture] Картинка
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public categoryPut(json: string, picture?: any, options?: any) {
        return CategoryApiFp(this.configuration).categoryPut(json, picture, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Удаление видео из курса
     * @param {number} categoryVideoId Идентификатор видео в курсе
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public categoryvideoDelete(categoryVideoId: number, options?: any) {
        return CategoryApiFp(this.configuration).categoryvideoDelete(categoryVideoId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Получение информации о видео в курсе
     * @param {number} categoryVideoId Идентификатор видео в курсе
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public categoryvideoGet(categoryVideoId: number, options?: any) {
        return CategoryApiFp(this.configuration).categoryvideoGet(categoryVideoId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Создание видео в курсе
     * @param {string} json JSON объект ReqPostCategoryVideo
     * @param {any} picture Картинка
     * @param {any} video Видео
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public categoryvideoPost(json: string, picture: any, video: any, options?: any) {
        return CategoryApiFp(this.configuration).categoryvideoPost(json, picture, video, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Изменение данных видео в курсе
     * @param {string} json JSON объект ReqPutCategoryVideo
     * @param {any} [picture] Картинка
     * @param {any} [video] Видео
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public categoryvideoPut(json: string, picture?: any, video?: any, options?: any) {
        return CategoryApiFp(this.configuration).categoryvideoPut(json, picture, video, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Получение информации о видео курса
     * @param {number} categoryId Идентификатор курса
     * @param {number} [offset] Смещение получения записей
     * @param {number} [limit] Лимит получения записей
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public categoryvideosGet(categoryId: number, offset?: number, limit?: number, options?: any) {
        return CategoryApiFp(this.configuration).categoryvideosGet(categoryId, offset, limit, options)(this.fetch, this.basePath);
    }

}

/**
 * FileApi - fetch parameter creator
 * @export
 */
export const FileApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Картинка
         * @param {number} fileId Идентификатор файла
         * @param {number} [width] Ширина картинки
         * @param {number} [height] Высота картинки
         * @param {number} [type] Тип трансформации картинки
         * @param {number} [blur] Размытие картинки
         * @param {number} [cornerRadius] Закругление углов картинки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureGet(fileId: number, width?: number, height?: number, type?: number, blur?: number, cornerRadius?: number, options: any = {}): FetchArgs {
            // verify required parameter 'fileId' is not null or undefined
            if (fileId === null || fileId === undefined) {
                throw new RequiredError('fileId','Required parameter fileId was null or undefined when calling pictureGet.');
            }
            const localVarPath = `/picture`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fileId !== undefined) {
                localVarQueryParameter['file_id'] = fileId;
            }

            if (width !== undefined) {
                localVarQueryParameter['width'] = width;
            }

            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (blur !== undefined) {
                localVarQueryParameter['blur'] = blur;
            }

            if (cornerRadius !== undefined) {
                localVarQueryParameter['corner_radius'] = cornerRadius;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Видео
         * @param {number} fileId Идентификатор файла
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videoGet(fileId: number, options: any = {}): FetchArgs {
            // verify required parameter 'fileId' is not null or undefined
            if (fileId === null || fileId === undefined) {
                throw new RequiredError('fileId','Required parameter fileId was null or undefined when calling videoGet.');
            }
            const localVarPath = `/video`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            if (fileId !== undefined) {
                localVarQueryParameter['file_id'] = fileId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FileApi - functional programming interface
 * @export
 */
export const FileApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Картинка
         * @param {number} fileId Идентификатор файла
         * @param {number} [width] Ширина картинки
         * @param {number} [height] Высота картинки
         * @param {number} [type] Тип трансформации картинки
         * @param {number} [blur] Размытие картинки
         * @param {number} [cornerRadius] Закругление углов картинки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureGet(fileId: number, width?: number, height?: number, type?: number, blur?: number, cornerRadius?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = FileApiFetchParamCreator(configuration).pictureGet(fileId, width, height, type, blur, cornerRadius, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return optimisation(response.json());
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Видео
         * @param {number} fileId Идентификатор файла
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videoGet(fileId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = FileApiFetchParamCreator(configuration).videoGet(fileId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return optimisation(response.json());
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * FileApi - factory interface
 * @export
 */
export const FileApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Картинка
         * @param {number} fileId Идентификатор файла
         * @param {number} [width] Ширина картинки
         * @param {number} [height] Высота картинки
         * @param {number} [type] Тип трансформации картинки
         * @param {number} [blur] Размытие картинки
         * @param {number} [cornerRadius] Закругление углов картинки
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pictureGet(fileId: number, width?: number, height?: number, type?: number, blur?: number, cornerRadius?: number, options?: any) {
            return FileApiFp(configuration).pictureGet(fileId, width, height, type, blur, cornerRadius, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Видео
         * @param {number} fileId Идентификатор файла
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        videoGet(fileId: number, options?: any) {
            return FileApiFp(configuration).videoGet(fileId, options)(fetch, basePath);
        },
    };
};

/**
 * FileApi - object-oriented interface
 * @export
 * @class FileApi
 * @extends {BaseAPI}
 */
export class FileApi extends BaseAPI {
    /**
     * 
     * @summary Картинка
     * @param {number} fileId Идентификатор файла
     * @param {number} [width] Ширина картинки
     * @param {number} [height] Высота картинки
     * @param {number} [type] Тип трансформации картинки
     * @param {number} [blur] Размытие картинки
     * @param {number} [cornerRadius] Закругление углов картинки
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public pictureGet(fileId: number, width?: number, height?: number, type?: number, blur?: number, cornerRadius?: number, options?: any) {
        return FileApiFp(this.configuration).pictureGet(fileId, width, height, type, blur, cornerRadius, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Видео
     * @param {number} fileId Идентификатор файла
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public videoGet(fileId: number, options?: any) {
        return FileApiFp(this.configuration).videoGet(fileId, options)(this.fetch, this.basePath);
    }

}

/**
 * PushApi - fetch parameter creator
 * @export
 */
export const PushApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Создание push-уведомления
         * @param {ReqPostPush} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushPost(body: ReqPostPush, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling pushPost.');
            }
            const localVarPath = `/push`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basic required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ReqPostPush" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PushApi - functional programming interface
 * @export
 */
export const PushApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Создание push-уведомления
         * @param {ReqPostPush} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushPost(body: ReqPostPush, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ResEmpty> {
            const localVarFetchArgs = PushApiFetchParamCreator(configuration).pushPost(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return optimisation(response.json());
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PushApi - factory interface
 * @export
 */
export const PushApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Создание push-уведомления
         * @param {ReqPostPush} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushPost(body: ReqPostPush, options?: any) {
            return PushApiFp(configuration).pushPost(body, options)(fetch, basePath);
        },
    };
};

/**
 * PushApi - object-oriented interface
 * @export
 * @class PushApi
 * @extends {BaseAPI}
 */
export class PushApi extends BaseAPI {
    /**
     * 
     * @summary Создание push-уведомления
     * @param {ReqPostPush} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PushApi
     */
    public pushPost(body: ReqPostPush, options?: any) {
        return PushApiFp(this.configuration).pushPost(body, options)(this.fetch, this.basePath);
    }

}

function firstUpper(i: string) {
  return i.substr(0,1).toUpperCase() + i.substr(1)
}

function mainOptimisation(data: any) {
  let outData: any = {}

  for(let key in data) {
    let value = data[key]

    if(/_/.test(key))
      key = key.split('_').map(
        (e,i) => i === 0 ? e : 
          firstUpper(e)).join('')

    outData[key] = typeof value !== "object" ?
      value : mainOptimisation(value)
  }

  return outData
}

async function optimisation(data: any) {
  if(data instanceof Promise)
    data = await data

  return mainOptimisation(data)
}